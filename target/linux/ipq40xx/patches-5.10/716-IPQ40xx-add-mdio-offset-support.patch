--- a/drivers/net/mdio/mdio-ipq4019.c
+++ b/drivers/net/mdio/mdio-ipq4019.c
@@ -10,6 +10,7 @@
 #include <linux/of_address.h>
 #include <linux/of_mdio.h>
 #include <linux/of_gpio.h>
+#include <linux/of.h>
 #include <linux/phy.h>
 #include <linux/platform_device.h>
 
@@ -34,6 +35,8 @@
 
 struct ipq4019_mdio_data {
 	void __iomem	*membase;
+	u32 mdio_offset;
+	u32 mdio_offset_limit;
 };
 
 static int ipq4019_mdio_wait_busy(struct mii_bus *bus)
@@ -52,6 +55,9 @@
 	unsigned int data;
 	unsigned int cmd;
 
+	if(mii_id < priv->mdio_offset_limit)
+		mii_id += priv->mdio_offset;
+
 	if (ipq4019_mdio_wait_busy(bus))
 		return -ETIMEDOUT;
 
@@ -115,6 +121,9 @@
 	unsigned int data;
 	unsigned int cmd;
 
+	if(mii_id < priv->mdio_offset_limit)
+		mii_id += priv->mdio_offset;
+
 	if (ipq4019_mdio_wait_busy(bus))
 		return -ETIMEDOUT;
 
@@ -220,6 +229,7 @@
 {
 	struct ipq4019_mdio_data *priv;
 	struct mii_bus *bus;
+	struct device_node *mdio_node;
 	int ret;
 
 	ret = ipq4019_phy_reset(pdev);
@@ -234,6 +244,10 @@
 
 	priv = bus->priv;
 
+	mdio_node = of_node_get(pdev->dev.of_node);
+	of_property_read_u32(mdio_node, "qcom,mdio_offset", &priv->mdio_offset);
+	of_property_read_u32(mdio_node, "qcom,mdio_offset_limit", &priv->mdio_offset_limit);
+
 	priv->membase = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(priv->membase))
 		return PTR_ERR(priv->membase);
